Основная задача SAI — это проинтегрироваться с провайдерами конференций, которые их пишут (в данном случае TCS), выкачать из него конференции и позволить пользователю их расшифровать

Наша работа - разработка web-api для доступа к интерфейсу SAI и разработка бизнес-логики

БД - это persistent-хранилище (там всё - токены, инфо о пользователях, настройки файловой системы, сами расшифровки, запросы на расшифровки, журнал событий и т.д.)
Вся логика работы с БД сейчас в коде, в БД в виде процедур не выносилась, как в других продуктах
Мы пишем код по взаимодействию с самой нейросетью (Денис Индейкин)
В нашем случае движком (чёрным ящиком) выступают нейронки, мы общаемся с ними через gateway "supervisor" по web-socket (он вечно открытый, мы - сервер, к нам подключается нейронка)

Поддерживаемые функции в данный момент:
* распознавание аудио в текст
* конспектирование (отдаём уже распознанную конфу, промт и в ответ получаем выжимку)

(работает в докере, агенты на python, Денис И. может помочь, где там что)

Работа с клиентами:
* HTTP-запросы
* Открытые web-sockets (изменение статусов расшифровок и саммаризация, т.е. получение выжимки)


**ИНФРАСТРУКТУРА**

В инфрастуктуре есть 2 основных модуля:
* Модуль закачки
	* Занимается общением с провайдерами, т.е. с TCS-ами, и выкачивает из них конференции (мета-информацию и аудиофайлы)
	* Делится на background и sheduler:
		* background
			* Опрашивает TCS-ы на meta-информацию (узнаём, есть ли конференции, которые надо скачать)
		* sheduler
			* работает в фоновом режиме, имеет несколько воркеров (5, конфигурируемое значение). Он идёт по выкачанным конференциям (мета-данным) и смотрит, есть ли у них невыкачанные файлы. Если да, качаем
	* Дальше либо пользователь вызывает процесс распознавания, либо автоматически, если в конфе стоит флаг "распознать по окончании созвона", подключается модуль распознавания
* Модуль распознавания
	* Часть, которая общается с нейронкой
	* Мы получаем запрос на распознавание, берём из базы конфу, даём этому модулю симлинки, которые ведут в места файловой системы, где лежат выкачанные файлы (по сети мы файлы не гоняем). Нейронка возвращает статусы, и когда будет статус "Завершено", мы берём JSON, который сгенерила нейронка, пишем в БД и далее делимся им по запросу


Есть ещё модуль авторизации:
* Есть много вариантов:
	* токены, которые мы выдали пользователям
	* токены, которые мы выдали админам, а они их дают дальше
	* токены, которые сам TCS выписывает для своих админов, и мы их пропускаем как суперпользователей SAI
	* токены, которые TCS получает на основе своих токенов
	* и т.п.

Ещё есть модуль нотификаций:
* Отправляет уведомления, что конфа распознана
* Мы говорим TCS-ам "отправь вот такое уведомление вот таким людям"
* Там ещё есть плохо работающая нотификация по перегрузке памяти - в ней мало смысла, сложные условия на воспроизведение, лучше вообще её удалить

Модуль лицензирования как в Coordinator, БД - Postgresql.
Это хранилище, выступает в роле надстройки над фактической файловой системой. Выкачивается конфа, ей присваивается uid, мы берём его первые два символа, вторые два и третьи два - это названия папок, и получается тройная вложенность (т.о. вложенность везде одинаковая). Туда выкачиваются по папкам:
* сырые исходники - тройная вложенность
* в папке source создаётся директория по id расшифровки, и создаются сим-линки к файлам в файловой системе - эти директории все примаунчены к нейронке. Почему так: нейронке нельзя скормить uid-ы, а мы переименовываем файлы и даём путь нейронке к этой директории. Она ходит к этим файлам по sim-линкам, и кладёт в папку (какую?) результат - расшифровку json, mp3, wav и т.п. и даёт уведомление "по такому-то request id работу закончила". Мы идём, берём json и аудио. Кладём в /var/fs/result, а json распаршиваем и кладём в БД.
С summary ещё проще - отправляешь json с promt и текстом, получаешь ответ, (тоже json покороче), парсишь его и кладёшь в БД

На TCS team создана учётка Transcription Bot, настроена как отправитель

Интеграция TCS с SAI:
	TCS нам сообщает Client ID и Client Secret для oauth-приложения (как логин и пароль). Мы по этим данным входим в TCS, получаем токен и этим токеном подписываем запросы к API TCS. API TCS предоставляет запросы на выкачивание расшифровки, треков, на авторизацию, на работу с нотификатором (прямое обращение к API TCS - api/v4/что-то там/тело запроса, и он что-то в ответ присылает)