Есть 4 типа авторизации:
* Админ SAI
	* Один админ создаётся автоматически при развёртывании AI-сервера. Далее можно добавлять и удалять новых
	* При авторизации в интерфейсе SAI вводится логин-пароль. Мы по правилам собираем хэш, проверяем его на валидность, и если всё ок, выписываем пару токенов (access и refresh), подписываем их ключами (Константин Бушуев, там существует по 2 ключа админских и пользовательских) ==(где мы используем access и refresh, если дастся JWT?)==. Подписываем ==(или генерируем?)== токен JWT и отдаём, а себе записываем этот токен в БД, потом при новых запросах проверяем - если не соответствует, то инвалидируем
* Пользователи SAI (на самом деле пользователи TCS), которые вошли через ЛК SAI). Это есть в спеке
	* При нажатии кнопки "войти" к нам приходит запрос "дай авторизационную сессию". Мы генерируем UID. Это контекст, который используется потом с дополнительными данными, чтобы понять, что этот запрос относится к тому самому UID, а не к какому-то левому
	* Мы в ответ даём авторизационную сессию и URL, который ведёт на авторизационную страницу самого TCS
	* Фронтент рисует авторизационную страницу TCS, там пользователь вводит логин и пароль, бэкенд проверяет также, что пара валидна, и редиректает с тем UID и authorization code (TCS-ная вещь)
	* Это получается второй запрос с UID (session id) и authorization code. По Session code мы понимаем, какую сессию хотели авторизовать. Берём authorization code, идём с ним в auth.go, берём из кэша сессию, берём нужный TCS. Далее мы инициализируем клиент общения с TCS и авторизуемся с кодом, который он нам отдал. Код позволяет убедить TCS, что мы те, кем мы представились, и SAI хочет авторизовать пользователя через всё это
	* Получается, авторизовываем, резолвим, получаем один токен с TCS-а для этого пользователя, который авторизовался, и можем выполнять этим токеном его запросы. Тут же выкачиваем его профиль и аватарку и сохраняем это в БД. Если всё прошло без ошибок, пользователь создан/обновлён, мы тут выписываем свою пару токенов, а прошлые, которые описывал выше, забываем и нигде не храним
	* **ИТОГО: 
		* нажимаем в ЛК SAI "войти", SAI генерит UID и отправляет в ответ этот UID и URL страницы авторизации в TCS
		* Фронтенд рисует страницу авторизации в TCS, логинимся, получаем "auth code" и отправляем его со своим UID обратно на SAI. SAI проверяет у TCS, что этот "auth code" валидный, и в обмен получает access-токен, с помощью которого получает на TCS инфу о пользователе и сохраняет себе в БД, если там такого пользователя ещё не было. После - SAI забывает обо всём, выдаёт  свою пару токенов access+refresh, которые используются для всех последующих запросов пользователя к SAI** 
* Пользователи, которые вошли через ЛК TCS
	* TCS умеет проксировать запросы к SAI. Фронтенд TCS --> API TCS --> API SAI. Идёт по эндпоинту "frontTCS" ==(?)==
	* Делается аналогично, только пропускается редирект. Нам дали готовый токен пользователя, мы из SAI с этим токеном идём обратно в TCS, выкачиваем из него аватарку, создаём пользователя если его ещё нет, и выдаём пару токенов уже свои. Далее этими токенами подписывают свои запросы на расшифровки
	* Это иная стилизация того же самого экрана на тех же запросах, что и в ЛК SAI
* Админ TCS через ЛК SAI (становится суперпользователем)
	* Чтобы получить список конференций, нужно, чтобы у админа TCS был доступ на SAI. Как он обеспечивается. Т.к. админ TCS - это не просто пользователь, то через обработку пользователей, как описано выше, он бесшовно авторизоваться не сможет. Делается так. Мы знаем, что есть гарантированно одинаковый CLIENT-SECRET. Что делает TCS: Он берёт токен, генерирует JWT-токен (можно расшифровать на jwt.io) определённого труконфом вида, только подписывается не по rs256, а hs256 (просто хэш-строчка, это CLIENT-SECRET) - получается синхронный ключ (токен). Отправляется на SAI, проверяется, если совпадает контрольная сумма (третья часть после точки), значит токен не подделан, и мы предоставляем админу все расшифровки всех пользователей этого TCS. Сделано это за тем, если все пользователи удалят себе доступ к расшифровке (конфа станет ничья). Так админ сможет войти и дать всем им снова доступ 


