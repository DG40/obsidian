---
репозиторий: https://gitlab.trueconf.com/products/speech2text/web-api
контакты: |-
  Андрей Кравченко - архитектурные вопросы, вопросы по лицензированию 
  Иван Мелешко - продуктовые вопросы
  Наталья Пак - вопросы по спецификациям и взаимодействию компонентов системы
  Денис Индейкин - вопросы по взаимодействию с ANN-модулем
  Михаил Бабаянц - вопросы по взаимодействию с клиентами API
  Алекей Карасёв - вопросы по взаимодействию с TCS
  София Ворона - вопросы по CRM/получению ключей с прода рег. сервера
  Артур Глушенко - технические вопросы по реализации лицензирования на стороне рег. сервера
---
## Разделы
1. [[#Основные подходы]]
2. [[#Зоны ответственности]]
3. [[#Используемые инструменты]]
4. [[#Основные части проекта]]
	1. [[#Модуль закачки]]
	2. [[#Модуль распознавания]]
	3. [[#Авторизация]]
	4. [[#Модуль лицензирования]]
	5. [[#Мониторинг]]
	6. [[#Модуль нотификаций]]
	7. [[#Хранилище]]

## Основные подходы
Web API SAI является основным проектом, над которым предстоит работать backend-разработчику. Оно (API) является единой точкой хранения бизнес-логики приложения, а также является единой точкой обращения к остальным сервисам AI Server, будь то ANN-модуль или БД.

Архитектурно проект крайне схож с Web API TCG 2.0 и Web API Coordinator на golang

## Зоны ответственности
В обязанности разработчика Web API SAI (если он всего один) входит следующий список задач:
- Отсмотр спецификаций
- Проектирование технических решений
- Реализация технических решений
- Проектирование API взаимодействия с клиентами
- Участие в проектировании API ANN-модуля
- Участие в проектировании API взаимодействия с TCS
- устранение неполадок развёрнутых продуктов (на разработческих стендах самостоятельно, на стендах заказчиков через тех. поддержку)
- консультации тестировщиков, аналитиков, тех. поддержки и других разработчиков в их работе, если их вопросы связаны с Web API
- Планирование собственной работы
- *Поддержка библиотеки лицензирования [tclicense](https://gitlab.trueconf.com/libs/go/tclicense)

## Используемые инструменты
- Проект на golang
- В качестве роутера используется chi
- Для формирования запросов в БД используется библиотека [squirrel](https://github.com/Masterminds/squirrel). С ней следует ознакомиться для работы над проектом
- Для работы с WebSocket-соединениями клиентов используется [gorilla/websocket](https://github.com/gorilla/websocket)
- Для генерации документации используется [swaggo](https://github.com/swaggo/swag)
- Для валидации запросов используется [ozzo-validation](https://github.com/go-ozzo/ozzo-validation)
- В проекте также часто используются внутренние библиотеки TrueConf. Например, библиотека лицензирования [tclicense](https://gitlab.trueconf.com/libs/go/tclicense) или [utils](https://gitlab.trueconf.com/libs/go/utils) и его субпакеты

## Основные части проекта
### Модуль закачки
Модуль закачки отвечает за выгрузку исходных файлов расшифровок из провайдеров

Несмотря на то, что на уровне бизнес-требований модуль закачки является единым, на практике в проекте Web API он разделён на 2 части - **infrastructure/background** и **infrastructure/scheduler**

**Background** - часть модуля, выполняющая выгрузку мета-информации о расшифровках. Выполняет периодические запросы к провайдерам, подключенным в полном доступе, для получения информации о новых расшифровках, которые ещё не были выгружены из него.

**Scheduler** - по имеющейся метаинформации о расшифровках выкачивает из провайдеров в полном доступе аудиофайлы, отправляемые, впоследствии, в ANN-модуль. Также данный модуль может инициировать автораспознавание расшифровок, если при выкачивании у них выставлен соответствующий флаг на TCS. Также, для регулирования нагрузки на сеть/ЦПУ есть возможность настройки количества воркеров, выполняющих выкачивание исходников.

### Модуль распознавания
Модуль распознавания является агентом API ANN-модуля продукта SAI, он выполняет все операции, связанные с обращениями к ANN-модулю, а также содержит связанную с этим логику по работе, например, с клиентами API или БД

Исходный код модуля находится в пакете **infrastructure/recognition**

Важные особенности реализации:
- Для работы с ANN-модулем при создании запроса на распознавание создаётся директория по пути /opt/trueconf/ai-server/var/lib/storage/recognition/source/{transcription_id}, в которую помещаются симлинки на файлы в [[#Хранилище]]
  Также при создании запроса на распозднавание создаётся директория по пути /opt/trueconf/ai-server/var/lib/storage/recognition/result/{transcription_id}, в которую ANN-модуль помещает результаты своей работы, которые, впоследствии, обрабатывает Web API

### Авторизация
Часть проекта, выполняющая авторизацию клиентов. Есть 4 основных сценария авторизации:
- **Авторизация администратора SAI**. Администратор SAI - внутренняя сущность проекта, имеющая пару логин/пароль. При отправке запроса на авторизаци, проверяется соответствие хэша пары той, что указана в БД, если они совпадают, то создаётся пара JWT, подписанные RSA-ключами, добавленными при инсталляции продукта
- **Авторизация пользователя через интерфейс SAI**. 
  1. Первым запросом к Web API SAI создаётся авторизационная сессия, которая выполняет роль контекста для следующего запроса клиента.  В ответе на первый запрос возвращается авторизационный URL для соответствующего провайдера и авторизационная сессия.
  2. Клиент переходит по полученному на предыдущем шаге URL, проходит авторизацию на стороне провайдера, после чего тот редиректит обратно на сторону SAI с заполненным authorization_code.
  3. Далее клиент обращается в Web API SAI второй раз, передавая в теле запроса авторизационную сессию и authorization_code
  4. Web API SAI обращается к провайдеру и обменивает authorization_code на токен пользователя TCS.
  5. С полученным токеном Web API SAI выполняет необходимые запросы для получения информации о пользователе, например, профиль и аватар
  6. В случае успеха вышеуказанных шагов Web API SAI считает авторизацию успешной и создаёт пару Access и Refresh JWT для пользователя, которыми уже можно будет подписывать дальнейшие запросы к Web API SAI
- **Авторизация пользователя через ЛК TCS**
  1. Клиент ЛК TCS отправляет запрос в backend TCS, который проксирует авторизационный запрос на SAI.
  2. SAI при получении соответствующего запроса проверяет валидность провайдера и выполняет логику из шагов 5 и 6 пункта "**Авторизация пользователя через интерфейс SAI**"
-  **Авторизация администратора TCS на SAI**. В данном случае провайдер генерирует JWT определённого содержания (подробнее описано в соответствующей спецификации) и подписывает его client_secret oAuth-приложения SAI. Метод подписи - HS256, в отличие от остальных способов авторизации.

**Уровни доступа токенов к данным**:
- Администратор SAI не имеет прямого доступа к чувствительным данным, например, расшифровкам пользователей
- Пользователи, в независимости от интерфейса (ЛК SAI или ЛК TCS) имеют доступ только к тем данным, к которым им явно выдан доступ
- Администраторы TCS являются суперпользователями SAI и имеют полный доступ ко всем расшифровками своего сервера

Логика авторизации разнесена по проекту, основная часть находится в пакете **core/jwt**, методы из него вызываются на уровне middleware транспортного слоя и при проверке доступа на слое **core**

### Модуль лицензирования
Модуль лицензирования выполняет работу по получению и обработке конфигураций продукта, указываемых на рег. сервере

Основная логика работы с лиц. сервером реализована в библиотеке [tclicense](https://gitlab.trueconf.com/libs/go/tclicense), сопровождение и разработка которой также входят в зону ответственности backend-разработчика SAI

В проекте Web API представлена обвязка для этой библиотеки, специфичная для SAI. Она расположена в пакете **infrastructure/license**

### Мониторинг
Выполняет сбор и возврат метрик работы продукта. Для сбора метрик используются хранимые процедуры в БД, подробнее про них можно прочитать здесь [[Работа с БД#Основные подходы]]

логика расположена в **core/monitoring**

### Модуль нотификаций
Модуль приложения, отвечающий за отправку нотификаций об изменении уровня доступа к расшифровке, готовности расшифровки, переполнении диска

Исходный код находится в **infrastructure/notifications**
### Хранилище
Для хранения файлов в SAI используется надстройка над файловой системой, которая работает следующим образом:
- В БД расположена таблица с метаинформацией и UUID, присваиваемыми файлам
- В файловой системе по пути **/opt/trueconf/ai-server/var/fs** располагаются директории, разделяющие хранимые файлы на типы, например **source** для исходников, **result** для сведённых аудиофайлов, **avatar** для аватаров пользователей
- При необходимости добавления файла в эту ФС создаётся запись в БД, из созданной записи берётся UUID
- Полученный UUID разбивается на 3 группы - первые 2 символа, вторые 2 символа и остаток
- Далее создаётся путь в соответствующей категории файлов в ФС по шаблонному пути <первые 2 символа UUID>/<вторые 2 символа UUDI>/название файла, содержащее полный UUID

Логика, описанная выше, расположена в **core/file_system**

Также в функционал хранилища входит отображение текущей загрузки диска, настройка допустимого занимаемого места и отправка нотификации о приближении к лимиту.

Данная логика описана в **infrastructure/storage**