ПЕРВАЯ ЗАДАЧА (СОСТОИТ ИЗ ДВУХ)
1. Доработки полномочий обычных пользователей, которые учёткой TCS пытаются получить доступ к каким-то объектам на SAI
	1. Поддержать на стороне SAI (который управляет настройками прав доступа к конкретному объекту, который он хранит) добавление групп к ролям
		1. У каждой стенограммы есть список ролей, у которой есть права и состав участников (id-s). Вот нужно добавить сюда группы, чтобы права можно было дать не только по id, но и по наличию пользователя в группе, входящей в такую-то роль
		2. Сейчас происходит так: в запросе приходит объект, мы с ним идём в БД, ищем его по id из запроса, смотрим, какая у него там указана роль (если вообще указана), и применяем ему права согласно этой роли
		3. А нужно сделать так: когда мы после авторизации запрашиваем ещё текущие группы пользователей в TCS, надо сделать доп. проверку - прописан ли пользователь явно по id, или есть какое-то пересечение по группам. В настройках стенограммы указано, что такие-то группы обладают такой-то ролью
	2. Доп. настройки на стороне TCS, которые TCS вычисляет отдельно в контексте каждого пользователя и формирует два флага:
		1. является ли этот пользователь суперпользователем SAI (transcription_moderator)
			1. Суперпользователь SAI - значит он находится неявно в группе "модераторы" каждой транскрибации, даже если он там не прописан явно (глобальная настройка такая)
		2. разрешено ли пользователю вообще работать с SAI (transcription_enable)
		

Комбинации этих двух флагов с TCS:

| 1.2 | transcription_enable | transcription_moderator | Права                                                                                                                                                |
| --- | -------------------- | ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
|     | false                | false                   | Запрет доступа независимо от текущих настроек прав в самом объекте стенограммы на стороне SAI                                                        |
|     | true                 | false                   | skip: всё как есть сейчас                                                                                                                            |
|     | false                | true                    | Интерпретируем как запрет, потому что это ошибка (такой комбинации приходить не должно, "transcription_moderator" зависит от "transcription_enable") |
|     | true                 | true                    | skip-аем проверку прав по конкретному ID и считаем, что этому пользователю можно всё (т.е. повышаем привилегии до максимального)                     |

ВТОРАЯ ЗАДАЧА
Изменение механизма предоставления прав доступа админам TCS, которые пытаются получить доступ к каким-то объектам на SAI


-----------------------------------------------------------------------------
1. Есть end-поинты в API SAI, которые отвечают на запросы пользователя по выдаче ему данных, и в них есть функция (или блок), который вычисляет, какое решение надо принять. Вот надо эту функцию найти и добавить перед той логикой, которая сейчас есть, свою, которая будет анализировать те 2 флага и принимать решение "запрет", "skip" или обычная проверка
2. Поддержать возможность сохранять права доступа каждого объекта не только по ID пользователя, но и по ID группы, в которой есть этот пользователь
3. Третья задача решается на стороне TCS по-идее. Андрей вспомнит, как админ TCS авторизует свои запросы объектам SAI, т.к. (как он говорит) админ TCS не может авторизоваться в ЛК SAI, в него может зайти только пользователь TCS. У SAI нет своих пользователей и своей страницы авторизации, у него есть только кэш пользователей, которых он запрашивает через oauth в TCS (как авторизация через соцсети). Тут разные соцсети - это разные TCS-ы. Пользователь выбирает свой TCS, ему открывается pop-ап-окно конкретно этого TCS, он вводит свои credentials
   Вот так реализована авторизация пользователем на SAI, авторизации админом на SAI вообще нет (она реализована вроде через JWT-токен)

_____________________________________________________________________
28.10.25
_____________________________________________________________________
ДОРАБОТКА АВТОРИЗАЦИИ ДОП.ЗАПРОСОМ С СОХРАНЕНИЕМ ДВУХ ФЛАГОВ, ПОЛУЧАЕМЫХ В ОТВЕТЕ

Мне нужно найти код, который реализует авторизацию. Там надо добавить дополнительный запрос профиля и прав (прав - это доп. эндпоинт)
Т.е. там, где делается запрос на /api/v4/me, нужно будет сделать ещё второй запрос (параметры запроса уточнить у Юсупова Руслана или у Гальвиты Саши, на сегодня не важно) - в ответ придут в JSON флаги типа "enable" и "is_moderator". Главное, что сделать - рядом с данными пользователями закэшировать эти два флага

Есть таблица пользователей. У каждого пользователя есть таблица токенов доступа к TCS, с помощью которых бэкенд вытягивает данные с TCS. Можно в этом токене хранить права в поле rights (костыльно, но пока пойдёт). Это нужно для того, чтобы иметь возможность по конкретному пользователю забрать эти два флага

Беру любой эндпоинт API в SAI, там дёргается модуль, который проверяет права доступа (сначала верифицирует JWT-токен, потом производит проверку валидности пользователя, который в этом токене содержится - т.е. производится проверка в БД нашей, есть он там или нет - если нет, вернётся ошибка). А теперь нужно после этой проверки добавить код, который полезет в БД, достанет сохранённые ранее 2 флага и скорректирует ответ в соответствии с таблицей:
* Если флаг "enable" == false, то возвращаем ту же ошибку, как "пользователя нет в БД", можно просто скопировать
* else - делаем проверку при "is_moderator" == false и скипаем при "is_moderator" == true

Можно сделать запрос на несуществующий эндпоинт, получить ошибку 404 и по хардкоду "получить" флаги с какими-нибудь значениями


Таблица token - это кэш, а не перманентная таблица. Она формируется при авторизации пользователей, т.е. после перезагрузки сервера SAI будет пустая
Таблица users - уже перманентная, её нельзя обнулять при перезагрузке, потому что данные пользователей подтягиваются тому, кто просит транскрибацию (ему же нужны ФИО, аватарки остальных участников)

Формулировка АШ:
* Получить требования к пользовательскому эндпоинту с TCS по правам
* Реализовать на tcs sdk
* Подтянуть изменения в API SAI
* Докинуть вызов нового эндпоинта в authUser (private)
* Дозаписать изменения в токен или БД
* Разобраться с админами (договориться с tcs, в каком виде будут передавать права), реализовать у себя
* Дописать decodeJWTtoken в core jwt
* Расширить методы проверки прав доступа к расшифровкам на слое core