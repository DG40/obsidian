* Увидел, что ca.crt - для беты, а нужен для прода. Поговорил с Артуром Глушенко про лицензирование SAI, зарегали на beta, надо зарегать на prod
	* Переустановил SAI, зарегал
* Помог Наталье Пак со списком ручек TCS, которые дёргаются при работе SAI
* Установить TCS или найти готовый (не ниже 5.5.1), в ЛК залогиниться как админ, там слева внизу будет интеграция с SAI. Там два варианта - ограниченный доступ (без возможности транскрибировать вроде) и полный. Ставлю полный, получаю код, вставляю его в SAI
	* Установил TCS на 10.110.2.137, не запускалась служба из-за отсутствия регистрации. А для регистрации надо было залогиниться, что не получалось без добавления пользователя в группу tcadmins. Добавил, залогиниться не получалось из-за работы не на 80 порту, который занимает SAI. Удалил SAI, переустановил TCS на 80 порт, всё получилось. 
	* Установил SAI (8088), хоть Настя Погорелова говорит, что на одной машине это работать не будет
	* Разбираюсь, как осуществить в TCS интеграцию с SAI. Получаю "error":"validation error at HostName: config and system host are not same"
* 
* 
* Поговорить с Валей, он хотел что-то переделать в сборке
* 
* ЗАВЕСТИ И СДЕЛАТЬ ЗАДАЧУ Доработать драйвера для их упрощения (проблема с разным наполнением функций разных моделей одного типа оборудования)
	* МЫСЛЬ ПРО ИМПЛЕМЕНТАЦИЮ НЕДОСТАЮЩИХ МЕТОДОВ - если в одном ВМИ есть метод, а во втором нету, то сейчас надо будет писать во всех моделях и в драйвере метод (в устройствах, не поддерживающих такой метод физически, будет описан этот метод, тупо возвращающий error). А можно сделать так:
		* В интерфейсе Entity убираем все методы, оставляем только "feedback" и добавляем метод "exec", которому приходит string (название метода) и data, а в файлах "core" самих моделей уже пишем switch case на exec и default-ом возвращаем "у данной модели нет такого метода"
* ЗАПУСТИТЬ SAI СО СВОИМ КОДОМ - проблема с лицензированием
* ДОТОЛКАТЬ ЗАДАЧУ НА ДАТЧИК WIRENBOARD
* Доделать mqtt (валидация входных данных по типу в запросе, нельзя посылать не строки - написал сейчас .(string), но это ломает прогу)
* Обсудить с Димой В. вариант дать стажёрам эту задачу:
	* https://op.trueconf.com/projects/commandant/work_packages/276650/
* Узнать у Кирилла Т., как он ведёт подготовку к инсталляции
* По 3 уровню С4 у Андрея был комментарий. Посмотреть, возможно поправить диаграмму


Что SAI вызывает в API TCS в фоновом режиме и режиме администратора  
  
1. Запрос user profile и прав при авторизации пользователя:  
2. GET /api/v4/me  
3. GET /api/v4/me/transcripts/permissions  
4. Выкачивание данных с TCS  
5. GET /api/v4.1/transcriptions?status=prepared Получение списка незагруженных транскрибаций  
6. GET /api/v4.1/transcriptions/{id} Получение профиля транскрибации по ID  
7. POST /api/v4/transcriptions/{transcription_id}/{command} С помощью этих сообщений SAI сообщает TCS о завершении очередного этапа  
8. GET /api/v4/transcriptions/{id}/tracks Получение списка файлов по транскрибации  
9. GET /api/v4/transcriptions/{id}/tracks/{file_uid} Получение файла транскрибации по id  
10. POST /api/v4/transcriptions/{transcription_id}/tracks/{file_uid}/downloaded Этой командой SAI сообщает TCS о успешной загрузке файла.  
11. Отправка событий API TCS для дальнейшей нотификации api/v4/servers-ai/notify:  
12. При сохранении (формировании) Записи с участниками в БД  
13. Окончание процесса распознания  
14. При добавлении права доступа к Стенограмме/Записи пользователя  
15. Превышение уровня диска для утилизации аудиофайлов


```
Yes—there are two additional TCS APIs that SAI hits directly beyond the list you shared:

- OAuth token endpoints (authorization-code and client-credentials grants).

SAI swaps an authorization code for a user access token during sign-in, and it repeatedly fetches service tokens for background jobs, notifications, and provider health checks.
tcsUserAuthInfo, err := client.AuthWithAuthorizationCode(ctx, &tcssdkmsg.AuthWithAuthorizationCodeRequest{
        ClientId:     connectionInfo.ClientId,
        ClientSecret: connectionInfo.ClientSecret,
        Code:         request.AuthCode,
    })
...

    authData, err := p.Client.AuthWithClientCredentials(
        authCtx,
        &tcssdkmsg.AuthWithClientCredentialsRequest{
            ClientId:     clientId,
            ClientSecret: clientSecret,
        },
    )
    p.AccessToken = authData.AccessToken

- User avatar download (TCS profile media API).

After login SAI requests the avatar file via the TCS SDK and stores/refreshes it locally.

    avatar, err := sdkClient.GetAvatar(ctx, &tcssdkmsg.GetAvatarRequest{
        AccessToken: tcssdkmsg.AccessTokenDto{
            AccessToken: accessToken,
        },
        UserId:  userId,
        Version: version,
    })
    ...

    if err := c.updateUserAvatar(ctx, ptr.Ref(file.Id), oldAvatarFileId, localUserId); err != nil {

Aside from those OAuth and avatar calls, the rest of SAI’s TCS traffic matches the list you already had (profile, transcript download workflow, status callbacks, and servers-ai/notify events).
```

```
Да, SAI обращается к двум дополнительным API TCS, помимо предоставленного вами списка:

* Энд-поинты токенов OAuth (коды авторизации и учётные данные клиента).
SAI заменяет код авторизации на токен доступа пользователя при входе в систему и многократно извлекает токены служб для фоновых заданий, уведомлений и проверок работоспособности поставщика. 
- POST
- /oauth2/v1/token

* Загрузка аватара пользователя (API медиа-профиля TCS).
После входа в систему SAI запрашивает файл аватара через TCS SDK и сохраняет/обновляет его локально.
- GET
- /api/{version}/users/{user_id}/avatar
```