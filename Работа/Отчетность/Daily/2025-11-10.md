* Исправил проблему с регистрацией SAI. Проблема заключалась в использовании файла ca.crt, который был сгенерирован под beta.crm, а не под prod
* Помог Наталье Пак перечислить список энд-поинтов TCS, которые используются при работе SAI
* Установил TCS на тестовом хосте. Сразу установить не получилось, уточнял у Богдана Колубай особенности установки. Нужно было добавить пользователя в группу ОС "tcadmins", а сервис разворачивать на 80 порту, который занимал SAI. Переустановил SAI на порт 8088. Остановился на том, как осуществить интеграцию TCS с SAI, т.к. получал "error":"validation error at HostName: config and system host are not same". Завтра продолжу
* 
* 
* Поговорить с Валей, он хотел что-то переделать в сборке
* 
* ЗАВЕСТИ И СДЕЛАТЬ ЗАДАЧУ Доработать драйвера для их упрощения (проблема с разным наполнением функций разных моделей одного типа оборудования)
	* МЫСЛЬ ПРО ИМПЛЕМЕНТАЦИЮ НЕДОСТАЮЩИХ МЕТОДОВ - если в одном ВМИ есть метод, а во втором нету, то сейчас надо будет писать во всех моделях и в драйвере метод (в устройствах, не поддерживающих такой метод физически, будет описан этот метод, тупо возвращающий error). А можно сделать так:
		* В интерфейсе Entity убираем все методы, оставляем только "feedback" и добавляем метод "exec", которому приходит string (название метода) и data, а в файлах "core" самих моделей уже пишем switch case на exec и default-ом возвращаем "у данной модели нет такого метода"
* ЗАПУСТИТЬ SAI СО СВОИМ КОДОМ - проблема с лицензированием
* ДОТОЛКАТЬ ЗАДАЧУ НА ДАТЧИК WIRENBOARD
* Доделать mqtt (валидация входных данных по типу в запросе, нельзя посылать не строки - написал сейчас .(string), но это ломает прогу)
* Обсудить с Димой В. вариант дать стажёрам эту задачу:
	* https://op.trueconf.com/projects/commandant/work_packages/276650/
* Узнать у Кирилла Т., как он ведёт подготовку к инсталляции
* По 3 уровню С4 у Андрея был комментарий. Посмотреть, возможно поправить диаграмму


Что SAI вызывает в API TCS в фоновом режиме и режиме администратора  
  
1. Запрос user profile и прав при авторизации пользователя:  
2. GET /api/v4/me  
3. GET /api/v4/me/transcripts/permissions  
4. Выкачивание данных с TCS  
5. GET /api/v4.1/transcriptions?status=prepared Получение списка незагруженных транскрибаций  
6. GET /api/v4.1/transcriptions/{id} Получение профиля транскрибации по ID  
7. POST /api/v4/transcriptions/{transcription_id}/{command} С помощью этих сообщений SAI сообщает TCS о завершении очередного этапа  
8. GET /api/v4/transcriptions/{id}/tracks Получение списка файлов по транскрибации  
9. GET /api/v4/transcriptions/{id}/tracks/{file_uid} Получение файла транскрибации по id  
10. POST /api/v4/transcriptions/{transcription_id}/tracks/{file_uid}/downloaded Этой командой SAI сообщает TCS о успешной загрузке файла.  
11. Отправка событий API TCS для дальнейшей нотификации api/v4/servers-ai/notify:  
12. При сохранении (формировании) Записи с участниками в БД  
13. Окончание процесса распознания  
14. При добавлении права доступа к Стенограмме/Записи пользователя  
15. Превышение уровня диска для утилизации аудиофайлов


```
Yes—there are two additional TCS APIs that SAI hits directly beyond the list you shared:

- OAuth token endpoints (authorization-code and client-credentials grants).

SAI swaps an authorization code for a user access token during sign-in, and it repeatedly fetches service tokens for background jobs, notifications, and provider health checks.
tcsUserAuthInfo, err := client.AuthWithAuthorizationCode(ctx, &tcssdkmsg.AuthWithAuthorizationCodeRequest{
        ClientId:     connectionInfo.ClientId,
        ClientSecret: connectionInfo.ClientSecret,
        Code:         request.AuthCode,
    })
...

    authData, err := p.Client.AuthWithClientCredentials(
        authCtx,
        &tcssdkmsg.AuthWithClientCredentialsRequest{
            ClientId:     clientId,
            ClientSecret: clientSecret,
        },
    )
    p.AccessToken = authData.AccessToken

- User avatar download (TCS profile media API).

After login SAI requests the avatar file via the TCS SDK and stores/refreshes it locally.

    avatar, err := sdkClient.GetAvatar(ctx, &tcssdkmsg.GetAvatarRequest{
        AccessToken: tcssdkmsg.AccessTokenDto{
            AccessToken: accessToken,
        },
        UserId:  userId,
        Version: version,
    })
    ...

    if err := c.updateUserAvatar(ctx, ptr.Ref(file.Id), oldAvatarFileId, localUserId); err != nil {

Aside from those OAuth and avatar calls, the rest of SAI’s TCS traffic matches the list you already had (profile, transcript download workflow, status callbacks, and servers-ai/notify events).
```

```
Да, SAI обращается к двум дополнительным API TCS, помимо предоставленного вами списка:

* Энд-поинты токенов OAuth (коды авторизации и учётные данные клиента).
SAI заменяет код авторизации на токен доступа пользователя при входе в систему и многократно извлекает токены служб для фоновых заданий, уведомлений и проверок работоспособности поставщика. 
- POST
- /oauth2/v1/token

* Загрузка аватара пользователя (API медиа-профиля TCS).
После входа в систему SAI запрашивает файл аватара через TCS SDK и сохраняет/обновляет его локально.
- GET
- /api/{version}/users/{user_id}/avatar
```